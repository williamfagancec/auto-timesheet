// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id             String   @id @default(cuid())
  email          String   @unique
  emailVerified  Boolean  @default(false) // NEW: Better-Auth email verification
  name           String?
  image          String? // NEW: Better-Auth profile image (OAuth)
  hashedPassword String? // Optional: null for OAuth-only users
  rmUserId       Int? // RM user ID for this user (used when creating time entries)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt // NEW: Better-Auth requires this

  sessions        Session[]
  accounts        Account[] // NEW: Better-Auth OAuth accounts
  projects        Project[]
  entries         TimesheetEntry[]
  rules           CategoryRule[]
  calendars       CalendarConnection[]
  events          CalendarEvent[]
  suggestionLogs  SuggestionLog[]
  rmConnection    RMConnection?
  projectDefaults UserProjectDefaults?
}

model Session {
  id        String   @id @default(cuid())
  userId    String
  expiresAt DateTime
  token     String   @unique // NEW: Better-Auth requires unique session token
  ipAddress String? // NEW: Better-Auth session tracking
  userAgent String? // NEW: Better-Auth session tracking
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt // NEW: Better-Auth requires this

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

// NOTE: OAuthState removed - Better-Auth handles OAuth state internally

model Account {
  id                    String    @id @default(cuid())
  accountId             String // Google user ID
  providerId            String // "google"
  userId                String
  accessToken           String? // Encrypted by Better-Auth
  refreshToken          String? // Encrypted by Better-Auth
  idToken               String? // OAuth ID token
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String? // For password provider (unused for OAuth)
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([providerId, accountId])
  @@index([userId])
}

model Verification {
  id         String   @id @default(cuid())
  identifier String // Email address
  value      String // Verification token
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@unique([identifier, value])
}

model CalendarConnection {
  id                  String @id @default(cuid())
  userId              String
  provider            String @default("google")
  selectedCalendarIds Json? // Array of calendar IDs to sync
  timezone            String @default("UTC") // User's timezone (e.g., "Australia/Sydney")

  // Calendar sync metadata
  lastSyncAt    DateTime?
  lastSyncError String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, provider])
  @@index([userId])
}

// NOTE: OAuth tokens (accessToken, refreshToken, expiresAt) moved to Account table
// NOTE: Diagnostic fields removed - Better-Auth handles token refresh monitoring

model Project {
  id         String   @id @default(cuid())
  userId     String
  name       String
  isArchived Boolean  @default(false)
  lastUsedAt DateTime @default(now())
  useCount   Int      @default(0)
  createdAt  DateTime @default(now())

  user           User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  entries        TimesheetEntry[]
  rules          CategoryRule[]
  suggestionLogs SuggestionLog[]
  rmMappings     RMProjectMapping[]

  @@index([userId, lastUsedAt])
}

model CalendarEvent {
  id            String   @id @default(cuid())
  googleEventId String
  userId        String
  calendarId    String // Google Calendar ID this event belongs to
  title         String
  startTime     DateTime
  endTime       DateTime
  attendees     Json?
  location      String?
  status        String   @default("confirmed") // confirmed, tentative, cancelled
  isAllDay      Boolean  @default(false)
  splitIndex    Int      @default(0) // 0 for non-split events, 1,2,3... for multi-day splits
  isDeleted     Boolean  @default(false) // Soft delete flag
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  user           User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  entry          TimesheetEntry?
  suggestionLogs SuggestionLog[]

  @@unique([userId, googleEventId, splitIndex])
  @@index([userId, startTime])
  @@index([userId, isDeleted])
  @@index([userId, startTime, endTime], map: "CalendarEvent_date_range_idx")
}

model TimesheetEntry {
  id         String   @id @default(cuid())
  userId     String
  eventId    String?  @unique
  projectId  String?
  date       DateTime
  duration   Int // in minutes
  isManual   Boolean  @default(false)
  isSkipped  Boolean  @default(false)
  notes      String?
  isBillable Boolean  @default(true)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  user               User                     @relation(fields: [userId], references: [id], onDelete: Cascade)
  event              CalendarEvent?           @relation(fields: [eventId], references: [id])
  project            Project?                 @relation(fields: [projectId], references: [id])
  rmSyncedComponents RMSyncedEntryComponent[]

  @@index([userId, date])
}

model CategoryRule {
  id               String    @id @default(cuid())
  userId           String
  ruleType         String // TITLE_KEYWORD, ATTENDEE_EMAIL, ATTENDEE_DOMAIN, CALENDAR_NAME, RECURRING_EVENT_ID
  condition        String // The pattern to match (e.g., keyword, email, domain, calendar ID, or event ID)
  projectId        String
  confidenceScore  Float     @default(0.5) // Base confidence score (0.0-1.0)
  matchCount       Int       @default(0) // Number of times this rule has been matched
  totalSuggestions Int       @default(0) // Total times this rule was suggested (accepted or rejected)
  accuracy         Float     @default(0) // Success rate: acceptedCount / totalSuggestions
  lastMatchedAt    DateTime? // Last time this rule was matched/suggested
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@unique([userId, ruleType, condition, projectId])
  @@index([userId, ruleType])
  @@index([userId, condition])
  @@index([userId, projectId])
  @@index([userId, accuracy(sort: Desc), totalSuggestions(sort: Desc)], map: "CategoryRule_performance_idx")
}

model SuggestionLog {
  id                 String   @id @default(cuid())
  userId             String
  eventId            String
  suggestedProjectId String
  confidence         Float // Confidence score of the suggestion (0.0-1.0)
  outcome            String // ACCEPTED, REJECTED, IGNORED
  createdAt          DateTime @default(now())

  user    User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  event   CalendarEvent @relation(fields: [eventId], references: [id], onDelete: Cascade)
  project Project       @relation(fields: [suggestedProjectId], references: [id], onDelete: Cascade)

  @@index([userId, outcome])
  @@index([userId, createdAt])
  @@index([eventId])
  @@index([userId, createdAt, outcome, confidence], map: "SuggestionLog_analytics_idx")
  @@index([userId, suggestedProjectId, createdAt], map: "SuggestionLog_project_idx")
}

// RM (Resource Management by Smartsheet) Integration Models

model RMConnection {
  id     String @id @default(cuid())
  userId String @unique

  // Encrypted API token (AES-256-GCM)
  encryptedToken String
  tokenIv        String
  tokenAuthTag   String

  // RM user info
  rmUserId    Int // User ID in RM system
  rmUserEmail String
  rmUserName  String?

  // Sync configuration
  autoSyncEnabled Boolean   @default(false) // Future: auto-sync on entry save
  lastSyncAt      DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user            User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  projectMappings RMProjectMapping[]
  syncLogs        RMSyncLog[]

  @@index([userId])
}

model RMProjectMapping {
  id           String @id @default(cuid())
  connectionId String

  // time-tracker project
  projectId String

  // RM project details
  rmProjectId   Int
  rmProjectName String
  rmProjectCode String?

  // Sync state
  enabled      Boolean   @default(true) // Allow users to temporarily disable
  lastSyncedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  connection    RMConnection    @relation(fields: [connectionId], references: [id], onDelete: Cascade)
  project       Project         @relation(fields: [projectId], references: [id], onDelete: Cascade)
  syncedEntries RMSyncedEntry[]

  @@unique([connectionId, projectId])
  @@unique([connectionId, rmProjectId])
  @@index([connectionId])
  @@index([projectId])
}

model RMSyncedEntry {
  id        String @id @default(cuid())
  mappingId String

  // RM entry details (one RM entry per project-day aggregate)
  rmEntryId  BigInt // ID returned by RM API (uses BigInt for large IDs)
  rmEntryUrl String? // Optional: deep link to RM entry

  // Aggregation metadata
  aggregationDate DateTime // Date for this aggregate (project-day combination)
  lastSyncedAt    DateTime
  lastSyncedHash  String // Hash of aggregated data (date + totalHours + isBillable + notes)
  syncVersion     Int      @default(1) // Increment on each update

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  mapping    RMProjectMapping         @relation(fields: [mappingId], references: [id], onDelete: Cascade)
  components RMSyncedEntryComponent[] // Multiple timesheet entries contributing to this RM entry

  @@unique([mappingId, aggregationDate]) // One RM entry per project-day
  @@index([mappingId])
  @@index([aggregationDate])
}

// Junction table tracking which timesheet entries contribute to aggregated RM entry
model RMSyncedEntryComponent {
  id               String @id @default(cuid())
  rmSyncedEntryId  String // The aggregated RM entry
  timesheetEntryId String // One of the contributing timesheet entries

  // Contribution metadata (for debugging/auditing)
  durationMinutes Int // Duration this entry contributed
  isBillable      Boolean // Billable status of this component
  notes           String? // Notes from this component

  createdAt DateTime @default(now())

  rmSyncedEntry  RMSyncedEntry  @relation(fields: [rmSyncedEntryId], references: [id], onDelete: Cascade)
  timesheetEntry TimesheetEntry @relation(fields: [timesheetEntryId], references: [id], onDelete: Cascade)

  @@unique([rmSyncedEntryId, timesheetEntryId]) // Each timesheet entry appears once per aggregate
  @@index([rmSyncedEntryId])
  @@index([timesheetEntryId])
}

model RMSyncLog {
  id           String @id @default(cuid())
  connectionId String

  // Sync job details
  jobId     String? // BullMQ job ID (future)
  status    RMSyncStatus
  direction RMSyncDirection // PUSH (time-tracker → RM)

  // Stats
  entriesAttempted Int @default(0)
  entriesSuccess   Int @default(0)
  entriesFailed    Int @default(0)
  entriesSkipped   Int @default(0)

  // Error tracking
  errorMessage String? @db.Text
  errorDetails Json? // Detailed error info for debugging

  startedAt   DateTime  @default(now())
  completedAt DateTime?

  connection RMConnection @relation(fields: [connectionId], references: [id], onDelete: Cascade)
  // NOTE: Partial unique index on (connectionId) WHERE status='RUNNING' is enforced
  // via raw SQL migration to prevent race conditions. Only one RUNNING sync per connection allowed.

  @@index([connectionId])
  @@index([status])
}

enum RMSyncStatus {
  PENDING
  RUNNING
  COMPLETED
  FAILED
  PARTIAL // Some entries succeeded, some failed
}

enum RMSyncDirection {
  PUSH // time-tracker → RM (MVP)
  PULL // RM → time-tracker (future)
  BIDIRECTIONAL // future
}

model UserProjectDefaults {
  id         String   @id @default(cuid())
  userId     String   @unique
  isBillable Boolean  @default(true)
  updatedAt  DateTime @updatedAt
  createdAt  DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}
