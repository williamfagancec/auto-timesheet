// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id             String   @id @default(cuid())
  email          String   @unique
  name           String?
  hashedPassword String?  // Optional: null for OAuth-only users
  createdAt      DateTime @default(now())

  sessions        Session[]
  projects        Project[]
  entries         TimesheetEntry[]
  rules           CategoryRule[]
  calendars       CalendarConnection[]
  events          CalendarEvent[]
  suggestionLogs  SuggestionLog[]
  rmConnection    RMConnection?
  projectDefaults UserProjectDefaults?
}

model Session {
  id        String   @id @default(cuid())
  userId    String
  expiresAt DateTime
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model CalendarConnection {
  id                  String    @id @default(cuid())
  userId              String
  provider            String    @default("google")
  accessToken         String
  refreshToken        String?
  expiresAt           DateTime?
  selectedCalendarIds Json?     // Array of calendar IDs to sync
  timezone            String    @default("UTC") // User's timezone (e.g., "Australia/Sydney")

  // Diagnostic fields for token refresh monitoring
  refreshTokenUpdatedAt DateTime? // When refresh token was last updated
  lastRefreshAttempt    DateTime? // When we last attempted to refresh the access token
  refreshFailureCount   Int       @default(0) // Count of consecutive refresh failures
  lastRefreshError      String?   // Last error message from refresh attempt (for debugging)

  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, provider])
  @@index([userId])
}

model Project {
  id         String   @id @default(cuid())
  userId     String
  name       String
  isArchived Boolean  @default(false)
  lastUsedAt DateTime @default(now())
  useCount   Int      @default(0)
  createdAt  DateTime @default(now())

  user            User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  entries         TimesheetEntry[]
  rules           CategoryRule[]
  suggestionLogs  SuggestionLog[]
  rmMappings      RMProjectMapping[]

  @@index([userId, lastUsedAt])
}

model CalendarEvent {
  id            String   @id @default(cuid())
  googleEventId String
  userId        String
  calendarId    String   // Google Calendar ID this event belongs to
  title         String
  startTime     DateTime
  endTime       DateTime
  attendees     Json?
  location      String?
  status        String   @default("confirmed") // confirmed, tentative, cancelled
  isAllDay      Boolean  @default(false)
  splitIndex    Int      @default(0) // 0 for non-split events, 1,2,3... for multi-day splits
  isDeleted     Boolean  @default(false) // Soft delete flag
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  user            User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  entry           TimesheetEntry?
  suggestionLogs  SuggestionLog[]

  @@unique([userId, googleEventId, splitIndex])
  @@index([userId, startTime])
  @@index([userId, isDeleted])
  @@index([userId, startTime, endTime], map: "CalendarEvent_date_range_idx")
}

model TimesheetEntry {
  id        String   @id @default(cuid())
  userId    String
  eventId   String?  @unique
  projectId String?
  date      DateTime
  duration  Int // in minutes
  isManual  Boolean  @default(false)
  isSkipped Boolean  @default(false)
  notes     String?
  isBillable Boolean @default(true)
  phase     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user          User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  event         CalendarEvent?  @relation(fields: [eventId], references: [id])
  project       Project?        @relation(fields: [projectId], references: [id])
  rmSyncedEntry RMSyncedEntry?

  @@index([userId, date])
}

model CategoryRule {
  id               String    @id @default(cuid())
  userId           String
  ruleType         String    // TITLE_KEYWORD, ATTENDEE_EMAIL, ATTENDEE_DOMAIN, CALENDAR_NAME, RECURRING_EVENT_ID
  condition        String    // The pattern to match (e.g., keyword, email, domain, calendar ID, or event ID)
  projectId        String
  confidenceScore  Float     @default(0.5) // Base confidence score (0.0-1.0)
  matchCount       Int       @default(0)   // Number of times this rule has been matched
  totalSuggestions Int       @default(0)   // Total times this rule was suggested (accepted or rejected)
  accuracy         Float     @default(0)   // Success rate: acceptedCount / totalSuggestions
  lastMatchedAt    DateTime? // Last time this rule was matched/suggested
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@unique([userId, ruleType, condition, projectId])
  @@index([userId, ruleType])
  @@index([userId, condition])
  @@index([userId, projectId])
  @@index([userId, accuracy(sort: Desc), totalSuggestions(sort: Desc)], map: "CategoryRule_performance_idx")
}

model SuggestionLog {
  id                  String   @id @default(cuid())
  userId              String
  eventId             String
  suggestedProjectId  String
  confidence          Float    // Confidence score of the suggestion (0.0-1.0)
  outcome             String   // ACCEPTED, REJECTED, IGNORED
  createdAt           DateTime @default(now())

  user    User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  event   CalendarEvent @relation(fields: [eventId], references: [id], onDelete: Cascade)
  project Project       @relation(fields: [suggestedProjectId], references: [id], onDelete: Cascade)

  @@index([userId, outcome])
  @@index([userId, createdAt])
  @@index([eventId])
  @@index([userId, createdAt, outcome, confidence], map: "SuggestionLog_analytics_idx")
  @@index([userId, suggestedProjectId, createdAt], map: "SuggestionLog_project_idx")
}

// RM (Resource Management by Smartsheet) Integration Models

model RMConnection {
  id               String   @id @default(cuid())
  userId           String   @unique

  // Encrypted API token (AES-256-GCM)
  encryptedToken   String
  tokenIv          String
  tokenAuthTag     String

  // RM user info
  rmUserId         Int      // User ID in RM system
  rmUserEmail      String
  rmUserName       String?

  // Sync configuration
  autoSyncEnabled  Boolean  @default(false)  // Future: auto-sync on entry save
  lastSyncAt       DateTime?

  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  user             User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  projectMappings  RMProjectMapping[]
  syncLogs         RMSyncLog[]

  @@index([userId])
}

model RMProjectMapping {
  id                String   @id @default(cuid())
  connectionId      String

  // time-tracker project
  projectId         String

  // RM project details
  rmProjectId       Int
  rmProjectName     String
  rmProjectCode     String?

  // Sync state
  enabled           Boolean  @default(true)  // Allow users to temporarily disable
  lastSyncedAt      DateTime?

  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  connection        RMConnection      @relation(fields: [connectionId], references: [id], onDelete: Cascade)
  project           Project           @relation(fields: [projectId], references: [id], onDelete: Cascade)
  syncedEntries     RMSyncedEntry[]

  @@unique([connectionId, projectId])
  @@unique([connectionId, rmProjectId])
  @@index([connectionId])
  @@index([projectId])
}

model RMSyncedEntry {
  id                String   @id @default(cuid())
  mappingId         String

  // time-tracker entry
  timesheetEntryId  String   @unique

  // RM entry details
  rmEntryId         Int      // ID returned by RM API
  rmEntryUrl        String?  // Optional: deep link to RM entry

  // Sync metadata
  lastSyncedAt      DateTime
  lastSyncedHash    String   // Hash of (date + hours + notes) to detect changes
  syncVersion       Int      @default(1)  // Increment on each update

  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  mapping           RMProjectMapping @relation(fields: [mappingId], references: [id], onDelete: Cascade)
  timesheetEntry    TimesheetEntry   @relation(fields: [timesheetEntryId], references: [id], onDelete: Cascade)

  @@index([mappingId])
  @@index([timesheetEntryId])
}

model RMSyncLog {
  id               String         @id @default(cuid())
  connectionId     String

  // Sync job details
  jobId            String?        // BullMQ job ID (future)
  status           RMSyncStatus
  direction        RMSyncDirection  // PUSH (time-tracker → RM)

  // Stats
  entriesAttempted Int            @default(0)
  entriesSuccess   Int            @default(0)
  entriesFailed    Int            @default(0)
  entriesSkipped   Int            @default(0)

  // Error tracking
  errorMessage     String?        @db.Text
  errorDetails     Json?          // Detailed error info for debugging

  startedAt        DateTime       @default(now())
  completedAt      DateTime?

  connection       RMConnection   @relation(fields: [connectionId], references: [id], onDelete: Cascade)

  @@index([connectionId])
  @@index([status])
  // NOTE: Partial unique index on (connectionId) WHERE status='RUNNING' is enforced
  // via raw SQL migration to prevent race conditions. Only one RUNNING sync per connection allowed.
}

enum RMSyncStatus {
  PENDING
  RUNNING
  COMPLETED
  FAILED
  PARTIAL  // Some entries succeeded, some failed
}

enum RMSyncDirection {
  PUSH           // time-tracker → RM (MVP)
  PULL           // RM → time-tracker (future)
  BIDIRECTIONAL  // future
}

model UserProjectDefaults {
  id         String   @id @default(cuid())
  userId     String   @unique
  isBillable Boolean  @default(true)
  phase      String?
  updatedAt  DateTime @updatedAt
  createdAt  DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}
